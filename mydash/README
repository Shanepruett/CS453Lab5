

****************
* Project 5/Shell Project Part 2 (with Buddy System Memory Manager)
* CS 453: Operating Systems
* May 1st, 2015
* Shane Pruett
**************** 

OVERVIEW:

   The main work of this project was working on implementing the Buddy System
   Memory Manager. The Buddy System we're implementing is meant to replace the
   customary Malloc, though it works differently.   

   Mydash is a simple shell application that is capable of filename completion
   command history, executing commands, exiting with ctrl-d or "exit", changing
   directory with "cd", having a prompt set by the global environment variable
   DASH_PROMPT, showing the version with "-v", executing process as background
   processes, mainting a list of running background process, and notifying the 
   user when a background process has compeleted. 

INCLUDED FILES:

   README			This readme file
   TestCases			File that has example test cases for mydash
   valgrind.supp		The suppression file for use with valgrind when using
				Malloc.
   git.log			A log file of git commits.

   .\dash			Directory for mydash
      mydash.c			This is the main file for the project. This file does
				looping, parsing, execing, and other tasks.
      mydash.h			The header file for mydash.c
      job.c			This is the job file that is used to keeping track of
				background processes.
      job.h			The header file for job.c
      git_version.c		This file is generated by the Makefile and is used by
				mydash to print the git version.
      git_version.h		The header file for git_version.c which is also 
				generated by the Makefile
      Makefile			The Makefile for the dash directory

   .\libsrc			Directory for libraries
      buddy.c			This is the buddy manager system implemented as a
	 			libary.
      buddy.h			This is the buddy manager header file.
      common.h			This is a header file used for Boolean typedef.
      List.c			This is the List file which is used to make a doubly
				circular linked list comprised of Nodes.
      List.h			The header file for List.c
      Node.c			This is the Node file which stores pointers to 
				objects and link to one another in the List.
      Node.h			The header file for Node.h
      Makefile			The Makefile for the libsrc directory, which installs
				the library files in subdirectories.

   .\include			The directory that will store header files for libararies
   .\lib			The directory that will store .a and .so files for the
				libraries upon make.
   .\test-harness		The directory containing example test harnesses.
   .\testsuite			The directory containing tests for List.
   .\buddy-test			The directory containing tests for the Buddy Manager
      buddy-test.c		The provided test file for the application.
      buddy-modified-test.c	The modified version of the test file I used for 
				troubleshooting issues with my buddy_free.
      malloc-test.c		The provided test file for the malloc comparison
      buddy-unit-test.c		The provided unist test file for the buddy manager.
      buddy-simple-test.c	The Test file used for initial testing of buddy manager
				as is was being written.


BUILDING AND RUNNING:

   Compile the program, from mydash directory type:
    $ make

   Run the dash program, from mydash directory type:
    $ mydash

   To use the libary for the buddy manager include it in your application.

PROGRAM DESIGN:

   When designing this program I used to slides from class to give me a good
   understanding about what to write as well as the exerts from the Information
   Structures book that was handed out in class.

   I started by writing the buddy_init function. I initially was using sbrk to
   also retrieve memory for the AVAIL list, but switch to statically allocated
   since I was always intializzing to 32Gb. I decided to have my AVAIL list
   keep record of just the pointer to the head of each block size instead of
   The method used in Information Structures. I use a structure called block to
   use as header information for each block of memory. The block has an unsigned
   tag used to determine if its being "used", unsigned kval to determine the
   save of the block of memory, and to block pointers prev and next to maintain
   a double linked list. Arguably it felt like a double linked list was unneccesary
   but I opted to maintain this sctructure, if I got this application working
   fully I would consider ruining my day by switching to a single linked list.

   
 

TESTING:

   I started off using my buddy-simple-test.c as soon as I started programming
   the buddy manager. This helped me work out the kinks at each step and gave
   me a wonderful false sense of security that I knew what I was doing and that
   I was pretty much a genius.

   After I got my project running flawllessly using my simple test I fell down
   the proverbial hole that was created by your provided test suites.

   The buddy-unit-test test revealed that I was not bothering to maintain my 
   AVAIL lists. After some revisions I got my code working flawlessly again.

   Then the buddy-test.c ruined the rest of my evenings. I have gone through
   many revisions of how I am doing my free, free starts breaking down as soon
   as I do a merge of buddies. I strongly suspect that my buddy finding method
   is the culprit as free works fine as long as there is no buddies. 

   To further test my buddy problems I made a modified version of buddy-test 
   that filled the array with "malloced" memory (my buddy_malloc seems to work 
   great), then systematically free those points. The lists are maintained 
   well until a buddy is found. My buddy finding seems to be finding incorrect
   buddies. I haven't been able to fix this yet.

DISCUSSION:

   I really hate using source control. It's been useful in this course because
   of how many places I have been doing my programming however. I did not use 
   svn because I find svn very unpleasant. I am using git and its quite nice.
   I am however out of private repositories so I will have to delete some things 
   this Summer.
 
   I'm so tired of googling and reading about pointer arithmetic. I'm going to 
   post here all my attempts at finding the correct buddy. You are free to laugh
   or cry as you please.

   Attempt 1: This worked wonderfulling as long as I wasn't paying attention. It 
   uses what I thought was the correct method to find a buddy using xor. It doesn't
   work.

	block *BUD = (block*) ((((void*)TMP - BASE) ^ (size_t) 1 << TMP->kval) + BASE);

   Attempt 2: After fiddling with xor for a while I abandoned hope for a while and
   implemented this monstrosity trying to be very literal with the slides and
   book. Are you not entertained?!

	unsigned long x = (void*) TMP - BASE;
        int addsub = 1;
        if (x % (1<<(k+1)) == (1<<k))
              addsub = -1;
        if (addsub)
              BUD = (block*) ((((void*)TMP - BASE) + ((size_t)1<<k)) + BASE);
        else
              BUD = (block*) ((((void*)TMP - BASE) - ((size_t)1<<k)) + BASE);

   Attempt 3: My current attempt is still failing. It's important to not that I get
   slightly different results with each implementation of this.

 	BUD = (block*) ((((size_t)TMP - (size_t)BASE) ^ ((size_t)1<<k)) + (size_t) BASE );

   Sadly this still is not working. It dawns on me that its possibly the split that
   is causing the problem. So I'm including the fundamental buddy making split line.
	
	block *SEC = (block*) ((((void*)AVAIL[k-1] - BASE) + ((size_t) 1 << (k-1))) + BASE) ;

  I've learned that its easier to make friends than buddies. I'm going to spend the few
  precious moments left of the evening to try to make all this work. So if it works
  when you get this submitted, know that I learned a valuable lesson, that is every 
  minute counts. If it doesn't work, I'm enjoying many beers by the time you read this.




EXTRA CREDIT:

   None.
