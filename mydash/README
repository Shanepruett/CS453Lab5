

****************
* Project 5/Shell Project Part 2 (with Buddy System Memory Manager)
* CS 453: Operating Systems
* May 1st, 2015
* Shane Pruett
**************** 

OVERVIEW:

   The main work of this project was working on implementing the Buddy System
   Memory Manager. The Buddy System we're implementing is meant to replace the
   customary Malloc, though it works differently.   

   Mydash is a simple shell application that is capable of filename completion
   command history, executing commands, exiting with ctrl-d or "exit", changing
   directory with "cd", having a prompt set by the global environment variable
   DASH_PROMPT, showing the version with "-v", executing process as background
   processes, mainting a list of running background process, and notifying the 
   user when a background process has compeleted. 

INCLUDED FILES:

   README			This readme file
   TestCases			File that has example test cases for mydash
   valgrind.supp		The suppression file for use with valgrind when using
				Malloc.
   git.log			A log file of git commits.

   .\dash			Directory for mydash
      mydash.c			This is the main file for the project. This file does
				looping, parsing, execing, and other tasks.
      mydash.h			The header file for mydash.c
      job.c			This is the job file that is used to keeping track of
				background processes.
      job.h			The header file for job.c
      git_version.c		This file is generated by the Makefile and is used by
				mydash to print the git version.
      git_version.h		The header file for git_version.c which is also 
				generated by the Makefile
      Makefile			The Makefile for the dash directory

   .\libsrc			Directory for libraries
      buddy.c			This is the buddy manager system implemented as a
	 			libary.
      buddy.h			This is the buddy manager header file.
      common.h			This is a header file used for Boolean typedef.
      List.c			This is the List file which is used to make a doubly
				circular linked list comprised of Nodes.
      List.h			The header file for List.c
      Node.c			This is the Node file which stores pointers to 
				objects and link to one another in the List.
      Node.h			The header file for Node.h
      Makefile			The Makefile for the libsrc directory, which installs
				the library files in subdirectories.

   .\include			The directory that will store header files for libararies
   .\lib			The directory that will store .a and .so files for the
				libraries upon make.
   .\test-harness		The directory containing example test harnesses.
   .\testsuite			The directory containing tests for List.
   .\buddy-test			The directory containing tests for the Buddy Manager
      buddy-test.c		The provided test file for the application.
      buddy-modified-test.c	The modified version of the test file I used for 
				troubleshooting issues with my buddy_free.
      malloc-test.c		The provided test file for the malloc comparison
      buddy-unit-test.c		The provided unist test file for the buddy manager.
      buddy-simple-test.c	The Test file used for initial testing of buddy manager
				as is was being written.


BUILDING AND RUNNING:

   Compile the program, from mydash directory type:
    $ make

   Run the dash program, from mydash directory type:
    $ mydash

   To use the libary for the buddy manager include it in your application.

PROGRAM DESIGN:

   When designing this program I used to slides from class to give me a good
   understanding about what to write as well as the exerts from the Information
   Structures book that was handed out in class.

   I started by writing the buddy_init function. I initially was using sbrk to
   also retrieve memory for the AVAIL list, but switch to statically allocated
   since I was always intializzing to 32Gb. I decided to maintain the size of 
   the AVAIL list at the max k value despite changing the init to potentially
   have less than that amount of memory available.

   I decided to have my AVAIL list keep record of just the pointer to the head 
   of each block size instead of The method used in Information Structures. 

   I use a structure called block to use as header information for each block 
   of memory. The block has an unsigned tag used to determine if its being "used",
   unsigned kval to determine the save of the block of memory, and to block 
   pointers prev and next to maintain a double linked list. Arguably it felt 
   like a double linked list was unneccesary but I opted to maintain this 
   sctructure, if I got this application working fully I would consider ruining 
   my day by switching to a single linked list.

   
 

TESTING:

   I started off using my buddy-simple-test.c as soon as I started programming
   the buddy manager. This helped me work out the kinks at each step and gave
   me a wonderful false sense of security that I knew what I was doing and that
   I was pretty much a genius.

   After I got my project running flawllessly using my simple test I fell down
   the proverbial hole that was created by your provided test suites.

   The buddy-unit-test test revealed that I was not bothering to maintain my 
   AVAIL lists. After some revisions I got my code working flawlessly again.

   Then the buddy-test.c ruined the rest of my evenings. I have gone through
   many revisions of how I am doing my free, free starts breaking down as soon
   as I do a merge of buddies. I strongly suspect that my buddy finding method
   is the culprit as free works fine as long as there is no buddies. 

   To further test my buddy problems I made a modified version of buddy-test 
   that filled the array with "malloced" memory (my buddy_malloc seems to work 
   great), then systematically free those points. The lists were  maintained 
   well until a buddy was found. My buddy finding seems to be finding incorrect
   buddies. I added a test to make sure the buddy that was found was in the 
   correct list.

   After fixing those bugs I modified my code to try to grab 32 Gb of memory in
   the init, and failing that to decrement the exponent asked for until it did
   get the correct amount or it fails when the amount allocated was less than
   the minimum or less than the amount asked for. I haven't come up with a way to
   test if this is working unfortunately, which is why I'm mentioning it here.

DISCUSSION:

   I really hate using source control. It's been useful in this course because
   of how many places I have been doing my programming however. I did not use 
   svn because I find svn very unpleasant. I am using git and its quite nice.
   I am however out of private repositories so I will have to delete some things 
   this Summer.
 
   I'm so tired of googling and reading about pointer arithmetic. I'm going to 
   post here all my attempts at finding the correct buddy. You are free to laugh
   or cry as you please.

   Attempt 1: This worked wonderfulling as long as I wasn't paying attention. It 
   uses what I thought was the correct method to find a buddy using xor. It doesn't
   work.

	block *BUD = (block*) ((((void*)TMP - BASE) ^ (size_t) 1 << TMP->kval) + BASE);

   Attempt 2: After fiddling with xor for a while I abandoned hope for a while and
   implemented this monstrosity trying to be very literal with the slides and
   book. Are you not entertained?!

	unsigned long x = (void*) TMP - BASE;
        int addsub = 1;
        if (x % (1<<(k+1)) == (1<<k))
              addsub = -1;
        if (addsub)
              BUD = (block*) ((((void*)TMP - BASE) + ((size_t)1<<k)) + BASE);
        else
              BUD = (block*) ((((void*)TMP - BASE) - ((size_t)1<<k)) + BASE);

   Attempt 3: My current attempt is still failing. It's important to not that I get
   slightly different results with each implementation of this.

 	BUD = (block*) ((((size_t)TMP - (size_t)BASE) ^ ((size_t)1<<k)) + (size_t) BASE );

   Sadly this still is not working. It dawns on me that its possibly the split that
   is causing the problem. So I'm including the fundamental buddy making split line.
	
	block *SEC = (block*) ((((size_t)AVAIL[k-1] - (size_t)BASE) + ((size_t) 1 << (k-1))) + (size_t)BASE) ;

  I've learned that its easier to make friends than buddies. I'm going to spend the few
  precious moments left of the evening to try to make all this work. So if it works
  when you get this submitted, know that I learned a valuable lesson, that is every 
  minute counts. If it doesn't work, I'm enjoying many beers by the time you read this.

  BREAKTHROUGH: After sleeping on it and doing some more thorough testing I realized the
  problem wasn't that I wasn't finding the correct Buddy address, but that the Buddy 
  address had been split since then and had a lower k value. I added the following code
  to ensure the buddy was in the right list and walla, no more seg faults. 

	if (k == BUD->kval)
        	buddy = BUD->tag; // buddy is used to evaluate whether a buddy was present.

INTERPOSING AND INTEGRATING DISCUSSION:

  To interpose my library I just added the malloc, free, calloc, and realloc functions to 
  my buddy manager and had them call the associated buddy version of the function. And because
  I didn't believe it when it started working right away I added some print lines when the
  function was called. here's a small snipped proving to me that it was working.

	[spruett@onyx mydash]$ LD_LIBRARY_PATH=. LD_PRELOAD=libbuddy.so ./mydash
	interposed: buddy_malloc
	interposed: buddy_malloc
	... more allocs ...
	interposed: buddy_malloc
	interposed: buddy_realloc
	interposed: buddy_malloc
	buddy-test  docs            doxygen.log  include     libbuddy.so  libmylib.so  Makefile  README     test-harness  testsuite
	dash        doxygen-config  git.log      libbuddy.a  libmylib.a   libsrc       mydash    TestCases  test.sh       valgrind.supp
	interposed: buddy_free
	interposed: buddy_free
	interposed: buddy_free
	interposed: buddy_free
	interposed: buddy_free
	interposed: buddy_malloc
	interposed: buddy_free
	interposed: buddy_malloc
	mydash>interposed: buddy_malloc
	exit
	interposed: buddy_free
	interposed: buddy_malloc
	interposed: buddy_malloc
	interposed: buddy_malloc
	interposed: buddy_malloc
	interposed: buddy_free
	interposed: buddy_free
	[spruett@onyx mydash]$
   
  Some basic testing I did to make sure it was behaving as it should. I have no idea where the
  strange "rN," is coming from in my dash program. But it does it when its interposed and when
  its not, so its a feature. This is just a snippet:

	[spruett@onyx mydash]$ LD_LIBRARY_PATH=. LD_PRELOAD=libbuddy.so ./mydash
	mydash>ls
	buddy-test  docs            doxygen.log  include     libbuddy.so  libmylib.so  Makefile  README     test-harness  valgrind.supp
	dash        doxygen-config  git.log      libbuddy.a  libmylib.a   libsrc       mydash    TestCases  testsuite
	mydash>sleep 5
	mydash>sleep 5&
	[1] 48276 sleep 5&
	mydash>jobs
	[1] Running sleep 5&
	mydash>
	[1] Done sleep 5&
	rN, mydash>
	mydash>sleep 10 &
	[1] 48493 sleep 10 &
	mydash>sleep 6 &
	[2] 48514 sleep 6 &
	mydash>joba
	Error: execvp failed
	mydash>jobs
	[1] Running sleep 10 &
	[2] Running sleep 6 &
	mydash>
	[1] Done sleep 10 &
	rN, [2] Done sleep 6 &
	rN, mydash>ls
	buddy-test  docs            doxygen.log  include     libbuddy.so  libmylib.so  Makefile  README     test-harness  valgrind.supp
	dash        doxygen-config  git.log      libbuddy.a  libmylib.a   libsrc       mydash    TestCases  testsuite
	mydash>
	mydash>exit
	[spruett@onyx mydash]$

EXTRA CREDIT:

  Buddy System Performance:
	This barely out performs but hey! (tested while ssh on to onyx, not optimized)

	[spruett@onyx mydash]$ time ./buddy-test/buddy-test 20000000 1234 s

	real    0m2.535s
	user    0m2.512s
	sys     0m0.006s
	[spruett@onyx mydash]$ time ./buddy-test/malloc-test 20000000 1234 s

	real    0m2.711s
	user    0m2.627s
	sys     0m0.003s
	[spruett@onyx mydash]$

